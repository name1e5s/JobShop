.TH "D:/Projects/JSSP-QT/src/algorithm/bottle.cpp" 3 "Fri Jun 15 2018" "Version iota" "JSSP Solver" \" -*- nroff -*-
.ad l
.nh
.SH NAME
D:/Projects/JSSP-QT/src/algorithm/bottle.cpp \- Core algorithms\&.  

.SH SYNOPSIS
.br
.PP
\fC#include <math\&.h>\fP
.br
\fC#include <time\&.h>\fP
.br
\fC#include <stdio\&.h>\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <bottle\&.h>\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBBLIST\fP"
.br
.ti -1c
.RI "struct \fBMACHINEORDER\fP"
.br
.ti -1c
.RI "struct \fBNEIGHBOR\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBTRY_COUNT\fP   10"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fBBLIST\fP \fBblist_t\fP"
.br
.ti -1c
.RI "typedef struct \fBMACHINEORDER\fP \fBmo_t\fP"
.br
.ti -1c
.RI "typedef struct \fBNEIGHBOR\fP \fBneighbor_t\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "static void \fBshifting_bottle_neck\fP (\fBsequence_t\fP *seq, \fBmo_t\fP *machine_order, int *try_time_set)"
.br
.RI "The major implementation of the Shifting Bottleneck Procedure, with a backtracing method\&. "
.ti -1c
.RI "static void \fBclear_and_backup_seq\fP (\fBsequence_t\fP *seq, int mach, int *save)"
.br
.ti -1c
.RI "static void \fBclear_seq\fP (\fBsequence_t\fP *seq, int machine)"
.br
.ti -1c
.RI "static void \fBcp_mo\fP (\fBmo_t\fP *mew, \fBmo_t\fP *origin)"
.br
.ti -1c
.RI "static void \fBcp_seq\fP (\fBsequence_t\fP *mew, \fBsequence_t\fP *origin)"
.br
.ti -1c
.RI "static void \fBcp_neighbor\fP (\fBneighbor_t\fP *mew)"
.br
.ti -1c
.RI "static void \fBre_optimization_phase_1\fP (\fBsequence_t\fP *seq, \fBmo_t\fP *mo, int *makespan)"
.br
.ti -1c
.RI "static void \fBset_seq\fP (\fBsequence_t\fP *seq, int mach, int *order)"
.br
.ti -1c
.RI "static void \fBsave_times\fP (void)"
.br
.ti -1c
.RI "static void \fBre_optimization_phase_2\fP (\fBsequence_t\fP *seq, \fBmo_t\fP *mo, int *makespan)"
.br
.ti -1c
.RI "static void \fBrestore_neighbor\fP (\fBneighbor_t\fP *old)"
.br
.ti -1c
.RI "static int \fBcritical\fP (int machine, int makespan)"
.br
.ti -1c
.RI "int \fBeval\fP (\fBsequence_t\fP *seq)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "int \fBbest_makespan\fP = \fBINFINITAS\fP"
.br
.RI "Store the best makespan value\&. "
.in -1c
.SH "Detailed Description"
.PP 
Core algorithms\&. 

Core algorithms to solve the JSSP\&.
.PP
\fBAuthor:\fP
.RS 4
Name1e5s 
.RE
.PP

.PP
Definition in file \fBbottle\&.cpp\fP\&.
.SH "Macro Definition Documentation"
.PP 
.SS "#define TRY_COUNT   10"

.PP
Definition at line 16 of file bottle\&.cpp\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBBLIST\fP  \fBblist_t\fP"
Store the bottle informnation\&. 
.SS "typedef struct \fBMACHINEORDER\fP  \fBmo_t\fP"
Machine order type\&. 
.SS "typedef struct \fBNEIGHBOR\fP  \fBneighbor_t\fP"
A temporary struct to store a sequence\&. 
.SH "Function Documentation"
.PP 
.SS "static void clear_and_backup_seq (\fBsequence_t\fP * seq, int machine, int * save)\fC [inline]\fP, \fC [static]\fP"
Store current sequence of machine N in the given address\&. Then just clear the sequence\&.
.PP
\fBParameters:\fP
.RS 4
\fIseq\fP Sequence to be cleared\&. 
.br
\fImachine\fP Current machine number\&. 
.br
\fIsave\fP Address to save the old sequence\&. A NULL address means the old sequence won't be stored\&. 
.RE
.PP

.PP
Definition at line 368 of file bottle\&.cpp\&.
.SS "static void clear_seq (\fBsequence_t\fP * seq, int machine)\fC [inline]\fP, \fC [static]\fP"
Clear the sequence\&.
.PP
\fBParameters:\fP
.RS 4
\fIseq\fP Sequence to be cleared\&. 
.br
\fImachine\fP Current machine number\&. 
.RE
.PP

.PP
Definition at line 384 of file bottle\&.cpp\&.
.SS "static void cp_mo (\fBmo_t\fP * mew, \fBmo_t\fP * origin)\fC [inline]\fP, \fC [static]\fP"
Copy the origin machine order to mew\&. 
.PP
Definition at line 354 of file bottle\&.cpp\&.
.SS "static void cp_neighbor (\fBneighbor_t\fP * mew)\fC [inline]\fP, \fC [static]\fP"
Store neighbor to a neighbor_t varible\&. 
.PP
Definition at line 423 of file bottle\&.cpp\&.
.SS "static void cp_seq (\fBsequence_t\fP * mew, \fBsequence_t\fP * origin)\fC [inline]\fP, \fC [static]\fP"
Copy the origin sequence order to mew\&. 
.PP
Definition at line 396 of file bottle\&.cpp\&.
.SS "static int critical (int machine, int makespan)\fC [inline]\fP, \fC [static]\fP"
Test wether the machine is the critical machine, which means the end of the procedure of this machine is also the end of all the operations\&.
.PP
\fBParameters:\fP
.RS 4
\fImachine\fP Machine number to be tested\&. 
.br
\fImakespan\fP The given makespan 
.RE
.PP
\fBReturns:\fP
.RS 4
If the machine is the critical machine, return 1\&. Else return 0\&. 
.RE
.PP

.PP
Definition at line 344 of file bottle\&.cpp\&.
.SS "int eval (\fBsequence_t\fP * seq)"
Evaluate the makespan of the given sequence\&.
.PP
\fBParameters:\fP
.RS 4
\fIseq\fP The sequence of job\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
The makespan of the sequence\&. 
.RE
.PP

.PP
Definition at line 31 of file eval\&.cpp\&.
.SS "static void re_optimization_phase_1 (\fBsequence_t\fP * seq, \fBmo_t\fP * machine_order, int * makespan)\fC [inline]\fP, \fC [static]\fP"
The re-optimization\&.\&.\&. Phase 1
.PP
\fBParameters:\fP
.RS 4
\fIseq\fP The sequence 
.br
\fImachine_order\fP Machine order 
.br
\fImakespan\fP Current makespan 
.RE
.PP

.PP
Definition at line 219 of file bottle\&.cpp\&.
.SS "static void re_optimization_phase_2 (\fBsequence_t\fP * seq, \fBmo_t\fP * machine_order, int * makespan)\fC [inline]\fP, \fC [static]\fP"
The re-optimization\&.\&.\&. Phase 2
.PP
\fBParameters:\fP
.RS 4
\fIseq\fP The sequence 
.br
\fImachine_order\fP Machine order 
.br
\fImakespan\fP Current makespan 
.RE
.PP

.PP
Definition at line 284 of file bottle\&.cpp\&.
.SS "static void restore_neighbor (\fBneighbor_t\fP * old)\fC [inline]\fP, \fC [static]\fP"
Load neighbor from a neighbor_t varible\&. 
.PP
Definition at line 434 of file bottle\&.cpp\&.
.SS "static void save_times (void)\fC [inline]\fP, \fC [static]\fP"
Save current start time of each operation\&. 
.PP
Definition at line 446 of file bottle\&.cpp\&.
.SS "static void set_seq (\fBsequence_t\fP * seq, int machine, int * order)\fC [inline]\fP, \fC [static]\fP"
Set sequence by the given order\&.
.PP
\fBParameters:\fP
.RS 4
\fIseq\fP Sequence to be set\&. 
.br
\fImachine\fP The machine which the sequence relies on\&. 
.br
\fIorder\fP The given order\&. 
.RE
.PP

.PP
Definition at line 409 of file bottle\&.cpp\&.
.SS "static void shifting_bottle_neck (\fBsequence_t\fP * seq, \fBmo_t\fP * machine_order, int * try_time_set)\fC [inline]\fP, \fC [static]\fP"

.PP
The major implementation of the Shifting Bottleneck Procedure, with a backtracing method\&. The basic idea of the algorithm can be described as follows: It sequences the machines one by one successively, taking each time the machine identified as a bottleneck among the machine not yet sequenced\&. Every time after a mew machine is sequenced, all previously sequenced sequence will be locally re-optimized\&. Bottleneck identification and the local re-optimization are both based on solving a one machine scheduling problem, which is more easy than the JSSP\&. In this implementation a backtracing trick is introduced to improve the quality of the solution, which give us a method to use a slightly more time to run the basic shifting bottleneck procedure more times\&.
.PP
\fBParameters:\fP
.RS 4
\fIseq\fP The given sequence list\&. Will be updated when find a better makespan\&. 
.br
\fImachine_order\fP Machine order\&. 
.br
\fItry_time_set\fP Backtracing depth set\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
When the procedure is done\&. You should find the start time of the solution at the 'start' field of the struct array job\&. 
.RE
.PP

.PP
Definition at line 119 of file bottle\&.cpp\&.
.SH "Variable Documentation"
.PP 
.SS "best_makespan = \fBINFINITAS\fP"

.PP
Store the best makespan value\&. 
.PP
Definition at line 47 of file bottle\&.cpp\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for JSSP Solver from the source code\&.
